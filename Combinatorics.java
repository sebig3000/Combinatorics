/*
 * MIT License
 * 
 * Copyright (c) 2019 Sebastian Gössl
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */



package combinatorics;

import java.math.BigInteger;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.function.Consumer;



/**
 * Collection of methods to generate combinatorics patterns like combinations
 * & permutations.
 * For sets java.util.Set is used, for multisets or ordered arrangements
 * java.util.List is used.
 * 
 * The methods are named by the following pattern:
 * (partial)Combination/Permutation(Rep)(N)
 *  - Partial: the result hold less elements than the initial set (omitted
 * for combination because a non-partial combination is the initial set).
 *  - Combination: combinations of the initial set are generated.
 *  - Permutation: permutations of the initial set are generated.
 *  - Rep: elements can be in the result more than once
 *  - N: doesn't generate any patterns but calculates the number of patterns
 * that will be generated by the corresponding method
 * 
 * 
 * @author Gössl
 * @version 1.0 17.9.2019
 */
public class Combinatorics {
    
    /**
     * Returns the factorial of the given value.
     * 
     * @param n number that factorial should be calculated
     * @return factorial of the given number
     */
    public static BigInteger factorial(int n) {
        if(n < 0) {
            throw new ArithmeticException(
                    "Factorial only defined for positive integers");
        }
        
        
        BigInteger result = BigInteger.ONE;
        
        while(n > 0) {
            result = result.multiply(BigInteger.valueOf(n--));
        }
        
        return result;
    }
    
    /**
     * Returns the binomial coefficient of the given values.
     * 
     * @param n row in Pascals' triangle
     * @param r index of the entry in Pascal's triangle
     * @return binomial coefficient of the given values
     */
    public static BigInteger nCr(int n, int r) {
        if(n < r) {
            throw new ArithmeticException(
                    "Binomial coefficient only defined for n >= r");
        }
        
        
        final BigInteger dividend = factorial(n);
        final BigInteger divisor =
                factorial(n-r).multiply(factorial(r));
        
        return dividend.divide(divisor);
    }
    
    
    
    /**
     * Returns a copy of the set without the given element.
     * 
     * @param <E> type of the elements
     * @param set set to generate a subset from
     * @param without element to exclude in the subset
     * @return copy of the set without the given element
     */
    private static <E> Set<E> subSet(Set<E> set, E without) {
        final Set<E> result = new HashSet<>(set);
        result.remove(without);
        
        return result;
    }
    
    
    
    
    /**
     * Returns the number of possible permutations for a set of n elements.
     * 
     * @param n number of elements in the super set
     * @return number of possible permutations
     */
    public static BigInteger permutationN(int n) {
        return permutationN(n, n);
    }
    
    /**
     * Returns the number of possible partial permutations for a set of n
     * elements.
     * 
     * @param n number of elements in the super set
     * @param k number of elements in the partial permutation
     * @return number of possible permutations
     */
    public static BigInteger permutationN(int n, int k) {
        return factorial(n).divide(factorial(n - k));
    }
    
    /**
     * Performs the given action for every permutation of the given set.
     * 
     * @param <E> type of the elements
     * @param set set from which the elements should be taken
     * @param action action to be performed for every permutation
     */
    public static <E> void permutation(Set<E> set,
            Consumer<? super List<E>> action) {
        
        permutation(set, set.size(), action);
    }
    
    /**
     * Performs the given action for every pertial permutation of the given
     * set.
     * 
     * @param <E> type of the elements
     * @param set set from which the elements should be taken
     * @param k number of elements in the partial permutation
     * @param action action to be performed for every permutation
     */
    public static <E> void permutation(Set<E> set, int k,
            Consumer<? super List<E>> action) {
        
        permutationUtil(set, new ArrayList<>(k), k, action);
    }
    
    /**
     * Recursive method that generates permutations & partial permutations.
     * 
     * @param <E> type of the elements
     * @param elementsLeft elements that are left to be used (init with super
     * set)
     * @param result temporary result (init with an empty list)
     * @param k wanted number of elements in the result
     * @param action action to be performed for every permutation
     */
    private static <E> void permutationUtil(Set<E> elementsLeft,
            List<E> result, int k, Consumer<? super List<E>> action) {
        
        if(result.size() >= k) {
            action.accept(Collections.unmodifiableList(result));
            return;
        }
        
        for(E element : elementsLeft) {
            result.add(element);
            permutationUtil(subSet(elementsLeft, element), result, k, action);
            result.remove(result.size() - 1);
        }
        
        //This could also be done with a list that removes, calls the util
        //method and adds the element again. The choosen way is probably
        //cleaner but clearly not nearly as efficient as the list version.
        //The optimal way would be to generate a subset without a copying the
        //complete set similarly to List.sublist thats only a wrapper or to be
        //able to remove and add an element af a set while iterating over it
        /*
        for(int i=0; i<elementsLeft.size(); i++) {
            result.add(elementsLeft.remove(i));
            permutationUtil(elementsLeft, result, k, action);
            elementsLeft.add(i, result.remove(result.size()-1));
        }
        */
    }
    
    
    /**
     * Returns the number of possible permutations with repetitions for a set
     * of n elements.
     * 
     * @param n number of elements in the super set
     * @return number of possible permutations with repetitions
     */
    public static BigInteger permutationRepN(int n) {
        return permutationRepN(n, n);
    }
    
    /**
     * Returns the number of possible partial permutations with repetitios for
     * a set of n elements.
     * 
     * @param n number of elements in the super set
     * @param k number of elements in the partial permutation
     * @return number of possible permutations with repetitions
     */
    public static BigInteger permutationRepN(int n, int k) {
        return BigInteger.valueOf(n).pow(k);
    }
    
    /**
     * Performs the given action for every permutation with repetitions of the
     * given set.
     * 
     * @param <E> type of the elements
     * @param set set from which the elements should be taken
     * @param action action to be performed for every permutation with
     * repetitions
     */
    public static <E> void permutationRep(Set<E> set,
            Consumer<? super List<E>> action) {
        
        permutationRep(set, set.size(), action);
    }
    
    /**
     * Performs the given action for every pertial permutation with repetitions
     * of the given set.
     * 
     * @param <E> type of the elements
     * @param set set from which the elements should be taken
     * @param k number of elements in the partial permutation
     * @param action action to be performed for every permutation
     */
    public static <E> void permutationRep(Set<E> set, int k,
            Consumer<? super List<E>> action) {
        
        permutationRepUtil(set, new ArrayList<>(k), k, action);
    }
    
    /**
     * Recursive method that generates permutations & partial permutations
     * with repetitions.
     * 
     * @param <E> type of the elements
     * @param elements elements of the super set
     * @param result temporary result (init with an empty list)
     * @param k wanted number of elements in the result
     * @param action action to be performed for every permutation
     */
    private static <E> void permutationRepUtil(Set<E> elements, List<E> result,
            int k, Consumer<? super List<E>> action) {
        
        if(result.size() >= k) {
            action.accept(Collections.unmodifiableList(result));
            return;
        }
        
        for(E element : elements) {
            result.add(element);
            permutationRepUtil(elements, result, k, action);
            result.remove(result.size() - 1);
        }
    }
    
    
    
    /**
     * Returns the number of possible combinations of k elements for a set
     * of n elements.
     * 
     * @param n number of elements in the super set
     * @param k number of elements in the combination
     * @return number of possible combinations
     */
    public static BigInteger combinationN(int n, int k) {
        return nCr(n, k);
    }
    
    /**
     * Performs the given action for every combination of the given set.
     * 
     * @param <E> type of the elements
     * @param set set from which the elements should be taken
     * @param k number of elements in the combination
     * @param action action to be performed for every combination
     */
    public static <E> void combination(Set<E> set, int k,
            Consumer<? super Set<E>> action) {
        
        combinationUtil(set, new HashSet<>(k), k, action);
    }
    
    /**
     * Recursive method that generates combinations.
     * 
     * @param <E> type of the elements
     * @param elementsLeft elements that are left to be used (init with super
     * set)
     * @param result temporary result (init with an empty set)
     * @param k wanted number of elements in the result
     * @param action action to be performed for every combination
     */
    private static <E> void combinationUtil(Set<E> elements,
            Set<E> result, int k, Consumer<? super Set<E>> action) {
        
        if(result.size() >= k) {
            action.accept(Collections.unmodifiableSet(result));
            return;
        }
        
        final Set<E> newElements = new HashSet<>(elements);
        for(E element : elements) {
            result.add(element);
            newElements.remove(element);
            combinationUtil(newElements, result, k, action);
            result.remove(element);
        }
        /*
        for(int i=0; i<elements.size(); i++) {
            result.add(elements.get(i));
            combinationRepUtil(elements.subList(i+1, elements.size()),
                    result, k, action);
            result.remove(elements.get(i));
        }
        */
    }
    
    
    /**
     * Returns the number of possible combinations of k elements with
     * repetitions for a set of n elements.
     * 
     * @param n number of elements in the super set
     * @param k number of elements in the combination
     * @return number of possible combinations with repetitions
     */
    public static BigInteger combinationRepN(int n, int k) {
        return nCr(n+k-1, k);
    }
    
    /**
     * Performs the given action for every combination with repetitions of the
     * given set.
     * 
     * @param <E> type of the elements
     * @param set set from which the elements should be taken
     * @param k number of elements in the combination
     * @param action action to be performed for every combination with
     * repetitions
     */
    public static <E> void combinationRep(Set<E> set, int k,
            Consumer<? super List<E>> action) {
        
        combinationRepUtil(set, new ArrayList<>(k), k, action);
    }
    
    /**
     * Recursive method that generates combinations with repetitions.
     * 
     * @param <E> type of the elements
     * @param elementsLeft elements that are left to be used (init with super
     * set)
     * @param result temporary result (init with an empty list)
     * @param k wanted number of elements in the result
     * @param action action to be performed for every combination
     */
    private static <E> void combinationRepUtil(Set<E> elements,
            List<E> result, int k, Consumer<? super List<E>> action) {
        
        if(result.size() >= k) {
            action.accept(Collections.unmodifiableList(result));
            return;
        }
        
        final Set<E> newElements = new HashSet<>(elements);
        for(E element : elements) {
            result.add(element);
            combinationRepUtil(newElements, result, k, action);
            newElements.remove(element);
            result.remove(element);
        }
        /*
        for(int i=0; i<elements.size(); i++) {
            result.add(elements.get(i));
            combinationRepUtil(elements.subList(i, elements.size()),
                    result, k, action);
            result.remove(elements.get(i));
        }
        */
    }
    
    
    
    
    public static void main(String[] args) {
        
        final Set<Integer> set = new HashSet<>(
                Arrays.asList(new Integer[]{0, 1, 2, 3}));
        final int setN = set.size();
        final int setK = setN / 2;
        System.out.println("Set: " + set);
        System.out.println("n: " + setN + ", k: " + setK + "\n");
        
        
        
        System.out.println("Permutation: " + Combinatorics.permutationN(setN));
        Combinatorics.permutation(set, System.out::println);
        
        System.out.println("Partial permutation: "
                + Combinatorics.permutationN(setN, setK));
        Combinatorics.permutation(set, setK, System.out::println);
        System.out.println();
        
        
        System.out.println("Permutation with repetition: "
                + Combinatorics.permutationRepN(setN));
        Combinatorics.permutationRep(set, System.out::println);
        
        System.out.println("Partial permutation with repetition: "
                + Combinatorics.permutationRepN(setN, setK));
        Combinatorics.permutationRep(set, setK, System.out::println);
        System.out.println();
        
        
        
        System.out.println("Combination: "
                + Combinatorics.combinationN(setN, setK));
        Combinatorics.combination(set, setK, System.out::println);
        System.out.println();
        
        
        System.out.println("Combination with repetition: "
                + Combinatorics.combinationRepN(setN, setK));
        Combinatorics.combinationRep(set, setK, System.out::println);
        System.out.println();
    }
}
